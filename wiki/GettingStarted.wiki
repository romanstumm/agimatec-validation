#summary Getting started with agimatec-validation framework

= Requirements =

  * add agimatec-validation.jar, agimatec-jsr303.jar to the classpath of your project
  * you might need some of the following jars in the classpath, that agimatec-validation depends upon (for a current list refer to the dependencies list of the project [http://www.agimatec.de/documentation/public/agimatec-validation/site/dependencies.html Maven-Dependencies])

|| *!GroupId* || *!ArtifactId* || *Version* || *Optional* ||
|| javax.validation ||	[http://anonsvn.jboss.org/repos/hibernate/validator/trunk/ validation-api] || 1.0.0.GA || required (for agimatec-jsr303.jar only) ||
|| commons-beanutils || [http://commons.apache.org/beanutils/ commons-beanutils] || 1.8.2|| required ||
|| commons-collections || [http://commons.apache.org/collections/ commons-collections] || 3.2.1 || required ||
|| commons-logging || [http://commons.apache.org/logging/ commons-logging] || 1.1.1 || required ||
|| commons-lang || [http://commons.apache.org/lang/ commons-lang] || 2.4 || required ||
|| com.thoughtworks.xstream || [http://xstream.codehaus.org/download.html xstream ] || 1.3.1 || optional, for XML processing of bean-infos (proprietary) xml only. jsr303-xml deployment descriptor handled with JAX-B ||
|| org.freemarker || [http://freemarker.org/ freemarker] || 2.3.15 || optional, for JSON code generator ||
|| javax.xml.bind || jaxb-api || 2.1 || JDK1.5 only, agimatec-jsr303 only ||
|| com.sun.xml.bind || jaxb-impl || 2.1.3||JDK1.5 only, agimatec-jsr303 only ||

{{{
}}}


= Articels / JSR303 Documentation =
  * [http://www.agimatec.de/blog/?s=validierung&x=0&y=0 German blog entries about validation from agimatec]

  * [http://musingsofaprogrammingaddict.blogspot.com/2009/01/getting-started-with-jsr-303-beans.html Getting started with jsr-303 from Gunnar Morling ]

  * [http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/ch05s07.html Documentation Spring 3 Validation ]

= Examples =

== Using the JSR 303 API ==
If you want to use the standard JSR APIs, your code 
  * references classes in package javax.validation  
  * and directly uses classes in package com.agimatec.validation.jsr303

_Note: The JSR 303 API is still work-in-progress and might differ from what is documented here. To get working examples of the APIs, refer to the test cases in the test-source-jar._

1. create a validator for one of your business classes

a) You can do this by using JSR303 bootstrapping APIs:

{{{
// create a factory (call this once and hold the reference)
javax.valiation.ValidatorFactory factory = Validation.buildDefaultValidatorFactory();

// create validators using the factory
javax.valiation.Validator validator = factory.getValidator();
}}}

b) OR you can use agimatec-validation specific APIs:
{{{
// using AgimatecValidatorFactory (you can configure the factory)
javax.validation.Validator validator = AgimatecValidatorFactory.getDefault().getValidator();
}}}

2. validate an instance of your business class

{{{
// Customer customer = new Customer();
// ... some business code to create the customer instance

// validate the instance and its child objects
Set<ConstraintViolation<Customer>> violations = validator.validate(customer);
}}}

3. Create constraints for your classes with annotations

If you want the validator to find some !ConstraintViolations, annotate your business objects with the annotations in javax.validation or create your own annotations for custom validation rules.

{{{
public class Customer{
    @NotEmpty(groups = "last")
    private String firstName;
    @NotEmpty(groups = "first")
    private String lastName;
    @Length(max = 30, groups = "last")
    private String company;

    @Valid
    private List<Address> addresses;

    // ... getter and setter methods if required...
}
}}}


=== Experimental method-level validation ===
Though not yet part of the JSR-303 specification, you can have a look at the method-level validation API proposed in the specification:
{{{
import com.agimatec.validation.jsr303.extensions.*;

javax.validation.Validator validator = // or use javax.validation.Validation.buildDefaultValidatorFactory() API ...
  AgimatecValidatorFactory.getDefault().getValidator();

// this is an example of how to get an instance of MethodValidator
MethodValidator mv = validator.unwrap(MethodValidator.class);

}}}

== Using the agimatec-validation API ==
The framework offers additional features that are not part of the JSR-303 specification.

1. describe your business classes with XML

{{{
<beanInfos>
  <bean id="Address" impl="com.agimatec.validation.jsr303.example.Address">
    <property name="city" mandatory="true" maxLength="10"/>
    <relationship name="country" beanId="Country" mandatory="true"/>
  </bean>

  <bean id="Country" impl="com.agimatec.validation.jsr303.example.Country">
    <feature key="mainKey">
      <value class="string">isoCode</value>
    </feature>

    <property name="isoCode">
       <feature key="readonly">
         <value class="boolean">true</value>
       </feature>
    </property>
  </bean>
</beanInfos>
}}}

  * the xml describes two classes: Address and Country
  * validator validates Adress.country, because of {{{<relationship/>}}} tag, that links the address to its child country
  * you can add more "features" to both a {{{<bean/>}}} or a {{{<property/>}}} with the {{{<feature/>}}} tag.
  * the value of the feature can be of any type (based on XStream xml serializer)

You can also add custom validators or exchange the default validators:
{{{
<beanInfos>
  <validator id="email" java="com.agimatec.validation.routines.EMailValidation"/>

  <bean id="Customer" impl="com.agimatec.validation.jsr303.example.Customer">
    <property name="email">
      <validator refId="email"/>
    </property>
  </bean>
</beanInfos>
}}}

  * {{{<validator>}}} under {{{<beanInfos>}}} registers a custom-validator implementation that you can use for validating beans or properties described in the xml-file
  * the default validator has id="standard", when registering another implementation under this name, you hook in you custom validator instead of the default implementation
  * {{{<validator/>}}} tag can be added under {{{<property/>}}} or {{{<relationship/>}}} (property-level-validation) and under {{{<bean/>}}} (bean-level-validation). The attribute "refId" refers to the "id" of the {{{<validator/>}}} under {{{<beanInfos/>}}}

2. create a !BeanValidator

You need to register the xml-files at a XMLMetaBeanRegistry, so that the framework finds them. You can register multiple xml-files. When the same bean-id occurs in more than one file, the descriptions are merged into a single !MetaBean. Thus you can "decorate" and extend the meta data on different layers. (e.g. one xml file comes from the server, the other xml file describes features for the GUI layer).

{{{
// initialize code (once, e.g. as a static initializer):
MetaBeanManagerFactory.getRegistry().addResourceLoader("my-beanInfos.xml");

// business code:
BeanValidator validator = new BeanValidator();
}}}

3. validate your beans

{{{
Customer object = new Customer();
// ... some business code to create the customer instance

// you can access the MetaBean by class or by id
MetaBean metaBean = MetaBeanManagerFactory.getFinder().findForClass(Customer.class);

ValidationResults results = validator.validate(object, metaBean);
}}}

  * you can have more than one !MetaBean per class, that allows you to use different validation rules according to the role of the user or class, 
    * e.g. the Address class can have different validation rules when referenced from a Customer than from a Company
    * e.g. an administrator user can use different validation rules for Customer beans than a guest user

4. check the results

{{{
if(results.hasError(object, "firstName")) {
  // something wrong with customer.firstName
}
if(!results.getErrorsByOwner(object.getAddress()).isEmpty()) {
  // something wrong with customer.address.*
}
}}}